/*
Cloud DNS

This is the Rackspace Cloud DNS v2 contract.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dnsclient

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// DefaultAuthURL is the default authentication URL
const DefaultAuthURL = "https://identity.api.rackspacecloud.com/v2.0/tokens"

// AuthRequest represents the structure of the authentication request body
type AuthRequest struct {
	Auth struct {
		APIKeyCredentials struct {
			Username string `json:"username"`
			APIKey   string `json:"apiKey"`
		} `json:"RAX-KSKEY:apiKeyCredentials"`
		TenantID string `json:"tenantId"`
	} `json:"auth"`
}

// AuthResponse represents the structure of the authentication response
type AuthResponse struct {
	Access struct {
		Token struct {
			ID      string    `json:"id"`
			Expires time.Time `json:"expires"`
		} `json:"token"`
	} `json:"access"`
}

// TokenManager manages the authentication token and its expiration
type TokenManager struct {
	Token     string
	Expires   time.Time
	AuthURL   string
	Username  string
	APIKey    string
	TenantID  string
	client    *http.Client
}

// NewTokenManager creates a new TokenManager instance
func NewTokenManager(username, apiKey, tenantID string) *TokenManager {
	return &TokenManager{
		AuthURL:  DefaultAuthURL,
		Username: username,
		APIKey:   apiKey,
		TenantID: tenantID,
		client:   &http.Client{Timeout: 10 * time.Second},
	}
}

// IsTokenExpired checks if the token is expired or about to expire (within 5 minutes)
func (tm *TokenManager) IsTokenExpired() bool {
	if tm.Token == "" || tm.Expires.IsZero() {
		return true
	}
	// Consider token expired if it's within 5 minutes of expiration
	return time.Now().After(tm.Expires.Add(-5 * time.Minute))
}

// GetToken retrieves the current token or fetches a new one if expired
func (tm *TokenManager) GetToken() (string, error) {
	if !tm.IsTokenExpired() {
		return tm.Token, nil
	}

	return tm.fetchNewToken()
}

// fetchNewToken makes an API request to get a new authentication token
func (tm *TokenManager) fetchNewToken() (string, error) {
	// Prepare request body
	authReq := AuthRequest{}
	authReq.Auth.APIKeyCredentials.Username = tm.Username
	authReq.Auth.APIKeyCredentials.APIKey = tm.APIKey
	authReq.Auth.TenantID = tm.TenantID

	body, err := json.Marshal(authReq)
	if err != nil {
		return "", fmt.Errorf("failed to marshal request body: %v", err)
	}

	// Create HTTP request
	req, err := http.NewRequest("POST", tm.AuthURL, bytes.NewBuffer(body))
	if err != nil {
		return "", fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Auth-Key", tm.APIKey)

	// Execute request
	resp, err := tm.client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to execute request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	// Parse response
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %v", err)
	}

	var authResp AuthResponse
	if err := json.Unmarshal(bodyBytes, &authResp); err != nil {
		return "", fmt.Errorf("failed to unmarshal response: %v", err)
	}

	// Update token manager
	tm.Token = authResp.Access.Token.ID
	tm.Expires = authResp.Access.Token.Expires

	return tm.Token, nil
}

// ManageToken checks token expiration and retrieves a new token if necessary
func (tm *TokenManager) ManageToken() (string, error) {
	if tm.IsTokenExpired() {
		// fmt.Println("Token is expired or not yet generated.")
	} else {
		fmt.Println("Token is still valid.")
		fmt.Printf("Current token: %s\n", tm.Token)
		fmt.Printf("Token expires at: %s\n", tm.Expires.Format(time.RFC3339))
	}

	// fmt.Println("Attempting to retrieve token...")
	token, err := tm.GetToken()
	if err != nil {
		return "", fmt.Errorf("failed to get token: %v", err)
	}

	// fmt.Printf("Successfully retrieved token: %s\n", token)
	// fmt.Printf("Token expires at: %s\n", tm.Expires.Format(time.RFC3339))
	return token, nil
}
